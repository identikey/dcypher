// This file is @generated by prost-build.
/// Public key bundle (may contain multiple algorithm keys)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicKeyBundle {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// 32 bytes
    #[prost(bytes = "vec", tag = "2")]
    pub ed25519_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "3")]
    pub pq_keys: ::prost::alloc::vec::Vec<PqPublicKey>,
    #[prost(enumeration = "BackendId", tag = "4")]
    pub pre_backend: i32,
    /// Backend-specific serialization
    #[prost(bytes = "vec", tag = "5")]
    pub pre_public_key: ::prost::alloc::vec::Vec<u8>,
}
/// Post-quantum public key
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PqPublicKey {
    /// e.g., "ML-DSA-87"
    #[prost(string, tag = "1")]
    pub algorithm: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub key_data: ::prost::alloc::vec::Vec<u8>,
}
/// Secret key bundle (for storage/export only—NEVER transmit!)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecretKeyBundle {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// 32 bytes
    #[prost(bytes = "vec", tag = "2")]
    pub ed25519_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "3")]
    pub pq_keys: ::prost::alloc::vec::Vec<PqSecretKey>,
    #[prost(enumeration = "BackendId", tag = "4")]
    pub pre_backend: i32,
    /// Backend-specific serialization
    #[prost(bytes = "vec", tag = "5")]
    pub pre_secret_key: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PqSecretKey {
    #[prost(string, tag = "1")]
    pub algorithm: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub key_data: ::prost::alloc::vec::Vec<u8>,
}
/// Recryption key (for proxy)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecryptKeyProto {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    #[prost(enumeration = "BackendId", tag = "2")]
    pub backend: i32,
    /// Blake3 fingerprint of source
    #[prost(bytes = "vec", tag = "3")]
    pub from_pubkey_fingerprint: ::prost::alloc::vec::Vec<u8>,
    /// Blake3 fingerprint of destination
    #[prost(bytes = "vec", tag = "4")]
    pub to_pubkey_fingerprint: ::prost::alloc::vec::Vec<u8>,
    /// Backend-specific serialization
    #[prost(bytes = "vec", tag = "5")]
    pub key_data: ::prost::alloc::vec::Vec<u8>,
}
/// PRE ciphertext (wrapped key material)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CiphertextProto {
    #[prost(enumeration = "BackendId", tag = "1")]
    pub backend: i32,
    /// 0 = original, 1+ = recrypted
    #[prost(uint32, tag = "2")]
    pub level: u32,
    /// Backend-specific ciphertext
    #[prost(bytes = "vec", tag = "3")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Complete encrypted file (wire format)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptedFileProto {
    /// Format version (2)
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// PRE-encrypted KeyMaterial
    #[prost(message, optional, tag = "2")]
    pub wrapped_key: ::core::option::Option<CiphertextProto>,
    /// 32 bytes - Bao root of ciphertext
    #[prost(bytes = "vec", tag = "3")]
    pub bao_hash: ::prost::alloc::vec::Vec<u8>,
    /// Bao verification tree (~1% size)
    #[prost(bytes = "vec", tag = "4")]
    pub bao_outboard: ::prost::alloc::vec::Vec<u8>,
    /// XChaCha20 encrypted data
    #[prost(bytes = "vec", tag = "5")]
    pub ciphertext: ::prost::alloc::vec::Vec<u8>,
    /// Signs (wrapped_key || bao_hash)
    #[prost(message, optional, tag = "6")]
    pub signature: ::core::option::Option<MultiSignatureProto>,
}
/// Key material bundle (96 bytes, encrypted inside wrapped_key)
/// NOT transmitted separately—included here for documentation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyMaterialProto {
    /// 32 bytes - XChaCha20 key
    #[prost(bytes = "vec", tag = "1")]
    pub symmetric_key: ::prost::alloc::vec::Vec<u8>,
    /// 24 bytes - XChaCha20 nonce
    #[prost(bytes = "vec", tag = "2")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    /// 32 bytes - Blake3 of plaintext
    #[prost(bytes = "vec", tag = "3")]
    pub plaintext_hash: ::prost::alloc::vec::Vec<u8>,
    /// Original size in bytes
    #[prost(uint64, tag = "4")]
    pub plaintext_size: u64,
}
/// Multi-signature (classical + post-quantum)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiSignatureProto {
    /// 64 bytes
    #[prost(bytes = "vec", tag = "1")]
    pub ed25519_signature: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "2")]
    pub pq_signatures: ::prost::alloc::vec::Vec<PqSignatureProto>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PqSignatureProto {
    /// e.g., "ML-DSA-87"
    #[prost(string, tag = "1")]
    pub algorithm: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileMetadata {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// Blake3 of ciphertext (content address)
    #[prost(bytes = "vec", tag = "2")]
    pub file_hash: ::prost::alloc::vec::Vec<u8>,
    /// Ciphertext size
    #[prost(uint64, tag = "3")]
    pub total_size: u64,
    /// Unix timestamp
    #[prost(uint64, tag = "4")]
    pub created_at: u64,
    /// Blake3 fingerprint of owner's pubkey
    #[prost(bytes = "vec", tag = "5")]
    pub owner_fingerprint: ::prost::alloc::vec::Vec<u8>,
    /// PRE backend used
    #[prost(enumeration = "BackendId", tag = "6")]
    pub backend: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkProto {
    #[prost(uint32, tag = "1")]
    pub index: u32,
    /// Encrypted chunk data
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Optional: Bao slice proof for this chunk
    #[prost(bytes = "vec", tag = "3")]
    pub bao_proof: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityProto {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// Content address
    #[prost(bytes = "vec", tag = "2")]
    pub file_hash: ::prost::alloc::vec::Vec<u8>,
    /// Public key fingerprint
    #[prost(bytes = "vec", tag = "3")]
    pub granted_to: ::prost::alloc::vec::Vec<u8>,
    /// "read", "write", "delete", "share"
    #[prost(string, repeated, tag = "4")]
    pub operations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Unix timestamp (0 = no expiry)
    #[prost(uint64, tag = "5")]
    pub expires_at: u64,
    /// Who granted this
    #[prost(bytes = "vec", tag = "6")]
    pub issuer_fingerprint: ::prost::alloc::vec::Vec<u8>,
    /// Signs all above fields
    #[prost(message, optional, tag = "7")]
    pub signature: ::core::option::Option<MultiSignatureProto>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<FileMetadata>,
    #[prost(message, repeated, tag = "2")]
    pub chunks: ::prost::alloc::vec::Vec<ChunkProto>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadResponse {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<FileMetadata>,
    /// Pre-signed URLs for chunks
    #[prost(string, repeated, tag = "2")]
    pub chunk_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecryptRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub file_hash: ::prost::alloc::vec::Vec<u8>,
    /// Fingerprint of recrypt key
    #[prost(bytes = "vec", tag = "2")]
    pub recrypt_key_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecryptResponse {
    #[prost(message, optional, tag = "1")]
    pub new_wrapped_key: ::core::option::Option<CiphertextProto>,
}
/// PRE backend identifier
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BackendId {
    BackendUnknown = 0,
    /// OpenFHE BFV/PRE (post-quantum)
    BackendLattice = 1,
    /// IronCore recrypt (classical)
    BackendEcPairing = 2,
    /// NuCypher Umbral (classical)
    BackendEcSecp256k1 = 3,
    /// TFHE LWE PRE (post-quantum, fast)
    BackendTfhe = 4,
    /// Testing only
    BackendMock = 255,
}
impl BackendId {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BackendUnknown => "BACKEND_UNKNOWN",
            Self::BackendLattice => "BACKEND_LATTICE",
            Self::BackendEcPairing => "BACKEND_EC_PAIRING",
            Self::BackendEcSecp256k1 => "BACKEND_EC_SECP256K1",
            Self::BackendTfhe => "BACKEND_TFHE",
            Self::BackendMock => "BACKEND_MOCK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BACKEND_UNKNOWN" => Some(Self::BackendUnknown),
            "BACKEND_LATTICE" => Some(Self::BackendLattice),
            "BACKEND_EC_PAIRING" => Some(Self::BackendEcPairing),
            "BACKEND_EC_SECP256K1" => Some(Self::BackendEcSecp256k1),
            "BACKEND_TFHE" => Some(Self::BackendTfhe),
            "BACKEND_MOCK" => Some(Self::BackendMock),
            _ => None,
        }
    }
}
