syntax = "proto3";
package recrypt.v1;

// =============================================================================
// Core Cryptographic Types
// =============================================================================

// PRE backend identifier
enum BackendId {
    BACKEND_UNKNOWN = 0;
    BACKEND_LATTICE = 1;      // OpenFHE BFV/PRE (post-quantum)
    BACKEND_EC_PAIRING = 2;   // IronCore recrypt (classical)
    BACKEND_EC_SECP256K1 = 3; // NuCypher Umbral (classical)
    BACKEND_MOCK = 255;       // Testing only
}

// Public key bundle (may contain multiple algorithm keys)
message PublicKeyBundle {
    uint32 version = 1;
    bytes ed25519_key = 2;              // 32 bytes
    repeated PqPublicKey pq_keys = 3;
    BackendId pre_backend = 4;
    bytes pre_public_key = 5;           // Backend-specific serialization
}

// Post-quantum public key
message PqPublicKey {
    string algorithm = 1;               // e.g., "ML-DSA-87"
    bytes key_data = 2;
}

// Secret key bundle (for storage/export only—NEVER transmit!)
message SecretKeyBundle {
    uint32 version = 1;
    bytes ed25519_key = 2;              // 32 bytes
    repeated PqSecretKey pq_keys = 3;
    BackendId pre_backend = 4;
    bytes pre_secret_key = 5;           // Backend-specific serialization
}

message PqSecretKey {
    string algorithm = 1;
    bytes key_data = 2;
}

// Recryption key (for proxy)
message RecryptKeyProto {
    uint32 version = 1;
    BackendId backend = 2;
    bytes from_pubkey_fingerprint = 3;  // Blake3 fingerprint of source
    bytes to_pubkey_fingerprint = 4;    // Blake3 fingerprint of destination
    bytes key_data = 5;                 // Backend-specific serialization
}

// PRE ciphertext (wrapped key material)
message CiphertextProto {
    BackendId backend = 1;
    uint32 level = 2;                   // 0 = original, 1+ = recrypted
    bytes data = 3;                     // Backend-specific ciphertext
}

// =============================================================================
// Encrypted File Format
// =============================================================================

// Complete encrypted file (wire format)
message EncryptedFileProto {
    uint32 version = 1;                 // Format version (2)
    CiphertextProto wrapped_key = 2;    // PRE-encrypted KeyMaterial
    bytes bao_hash = 3;                 // 32 bytes - Bao root of ciphertext
    bytes bao_outboard = 4;             // Bao verification tree (~1% size)
    bytes ciphertext = 5;               // XChaCha20 encrypted data
    MultiSignatureProto signature = 6;  // Signs (wrapped_key || bao_hash)
}

// Key material bundle (96 bytes, encrypted inside wrapped_key)
// NOT transmitted separately—included here for documentation
message KeyMaterialProto {
    bytes symmetric_key = 1;            // 32 bytes - XChaCha20 key
    bytes nonce = 2;                    // 24 bytes - XChaCha20 nonce
    bytes plaintext_hash = 3;           // 32 bytes - Blake3 of plaintext
    uint64 plaintext_size = 4;          // Original size in bytes
}

// =============================================================================
// Signatures
// =============================================================================

// Multi-signature (classical + post-quantum)
message MultiSignatureProto {
    bytes ed25519_signature = 1;        // 64 bytes
    repeated PqSignatureProto pq_signatures = 2;
}

message PqSignatureProto {
    string algorithm = 1;               // e.g., "ML-DSA-87"
    bytes signature = 2;
}

// =============================================================================
// File Metadata (for listings, not full content)
// =============================================================================

message FileMetadata {
    uint32 version = 1;
    bytes file_hash = 2;                // Blake3 of ciphertext (content address)
    uint64 total_size = 3;              // Ciphertext size
    uint64 created_at = 4;              // Unix timestamp
    bytes owner_fingerprint = 5;        // Blake3 fingerprint of owner's pubkey
    BackendId backend = 6;              // PRE backend used
}

// =============================================================================
// Chunk Transfer (for streaming)
// =============================================================================

message ChunkProto {
    uint32 index = 1;
    bytes data = 2;                     // Encrypted chunk data
    bytes bao_proof = 3;                // Optional: Bao slice proof for this chunk
}

// =============================================================================
// Capabilities (access tokens)
// =============================================================================

message CapabilityProto {
    uint32 version = 1;
    bytes file_hash = 2;                // Content address
    bytes granted_to = 3;               // Public key fingerprint
    repeated string operations = 4;     // "read", "write", "delete", "share"
    uint64 expires_at = 5;              // Unix timestamp (0 = no expiry)
    bytes issuer_fingerprint = 6;       // Who granted this
    MultiSignatureProto signature = 7;  // Signs all above fields
}

// =============================================================================
// API Request/Response Messages
// =============================================================================

message UploadRequest {
    FileMetadata metadata = 1;
    repeated ChunkProto chunks = 2;
}

message DownloadResponse {
    FileMetadata metadata = 1;
    repeated string chunk_urls = 2;     // Pre-signed URLs for chunks
}

message RecryptRequest {
    bytes file_hash = 1;
    bytes recrypt_key_id = 2;           // Fingerprint of recrypt key
}

message RecryptResponse {
    CiphertextProto new_wrapped_key = 1;
}

